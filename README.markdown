# Data Structures and Algorithms Repository

## Overview
Welcome to the Data Structures and Algorithms Repository! 

My aim for this project is to serve as a comprehensive collection of problems and solutions implemented in Python, 
aimed at mastering fundamental and advanced concepts in computer science. The repository is a work in progress, with 
the **Recursion** section currently completed, featuring problems and solutions such as counting balanced substrings, 
summing nested lists, and counting substring occurrences. Additional topics listed below are planned for future 
implementation, with carefully crafted problems and recursive or iterative solutions.

The goal is to provide clear, well-documented code and explanations to aid learning and reference for students, 
developers, and enthusiasts of algorithms and data structures.

## Current Status
As of August 7, 2025, the repository includes:
- **Recursion**: Fully implemented with problems and solutions, including:
  - Counting valid nested parentheses pairs.
  - Summing numbers in nested lists.
  - Counting non-overlapping substring occurrences.
  - More recursion-based problems with detailed explanations.
  - Unit test for the vast majority of the problems is available.

Other data structures and algorithms listed below are planned for future development. Each topic will include a variety 
of problems with solutions, explanations, and, where applicable, unit tests to verify correctness.

## Data Structures
The following data structures will be covered, with problems and solutions added progressively:
1. **Recursion** - Completed with problems like balanced substring counting and nested list summation.
2. **Arrays** - Planned (e.g., array manipulation, searching, and sorting problems).
3. **Linked Lists** - Planned (e.g., singly/doubly linked lists, reversal, cycle detection).
4. **Stacks** - Planned (e.g., stack operations, expression evaluation).
5. **Queues** - Planned (e.g., queue implementations, priority queues).
6. **Maps & Hash Tables** - Planned (e.g., hash map operations, collision handling).
7. **Graphs** - Planned (e.g., graph representations, traversal algorithms).
8. **Trees** - Planned (e.g., tree traversals, height calculations).
9. **Binary Trees** - Planned (e.g., binary tree properties, traversals).
10. **Binary Search Trees** - Planned (e.g., BST operations, balancing).
11. **Self-Balancing Trees** - Planned (e.g., AVL trees, Red-Black trees).
12. **Heaps** - Planned (e.g., min/max heaps, heap sort).
13. **Tries** - Planned (e.g., trie operations, autocomplete).
14. **Segment Trees** - Planned (e.g., range queries, updates).
15. **Fenwick Trees** - Planned (e.g., binary indexed trees, cumulative sums).
16. **Disjoint Set Union** - Planned (e.g., union-find, path compression).
17. **Minimum Spanning Trees** - Planned (e.g., Kruskal’s, Prim’s algorithms).

## Algorithms
The following algorithms will be implemented with practical problems:
1. **Divide and Conquer** - Planned (e.g., merge sort, quick sort foundations).
2. **Linear Search** - Planned (e.g., basic search problems).
3. **Binary Search** - Planned (e.g., searching in sorted arrays).
4. **Bubble Sort** - Planned (e.g., simple sorting problems).
5. **Counting Sort** - Planned (e.g., non-comparison-based sorting).
6. **Quick Sort** - Planned (e.g., partition-based sorting).
7. **Merge Sort** - Planned (e.g., divide-and-conquer sorting).
8. **Radix Sort** - Planned (e.g., digit-based sorting).
9. **Breadth First Search** - Planned (e.g., graph traversal, shortest paths).
10. **Depth First Search** - Planned (e.g., graph traversal, cycle detection).
11. **Sieve of Eratosthenes** - Planned (e.g., prime number generation).
12. **Knuth-Morris-Pratt Algorithm** - Planned (e.g., string matching).
13. **Greedy Algorithms** - Planned (e.g., activity selection, Huffman coding).
14. **Dynamic Programming** - Planned (e.g., knapsack, longest common subsequence).
15. **Convex Hull** - Planned (e.g., Graham scan, Jarvis march).
16. **Floyd-Warshall / Roy-Floyd Algorithm** - Planned (e.g., all-pairs shortest paths).
17. **Dijkstra's Algorithm** - Planned (e.g., single-source shortest paths).
18. **Bellman-Ford Algorithm** - Planned (e.g., shortest paths with negative weights).
19. **Topological Sorting** - Planned (e.g., dependency resolution).

## Usage
To explore the repository:
1. Clone the repository: `git clone <repository-url>`.
2. Navigate to the desired topic (e.g., `Recursion/` for completed problems).
3. Run the Python scripts to see solutions in action (requires Python 3.x).
4. Check docstrings for problem descriptions, examples, and explanations.

Each solution includes detailed comments and docstrings with examples to illustrate the problem and approach.

## Contributing
Contributions are welcome! If you’d like to add problems, solutions, or improve existing code:
1. Fork the repository.
2. Create a branch for your changes: `git checkout -b feature/your-feature`.
3. Add your problem or solution in the appropriate directory (e.g., `Recursion/`, `Arrays/`).
4. Include clear documentation and, if possible, unit tests.
5. Submit a pull request with a description of your changes.

Please follow the existing code style and ensure solutions are well-documented.

## Caveat
Please note that unit tests, such as those implemented with the `unittest` framework, are not available for all 
functions, and some functions may lack comprehensive test coverage to verify their behavior across all possible inputs.
Having said that, it will be my attempt to aim for completion as much as possible. Attempt here is to understand the
core concepts and ideas and not to be exhaustive. 

## Future Plans
The repository will be updated regularly with new problems and solutions for the listed data structures and algorithms.
Each topic will include:
- A variety of problems (easy to advanced).
- Solutions with recursive and/or iterative approaches.
- Explanations of time and space complexity.
- Unit tests where applicable to ensure correctness.

Stay tuned for updates as more content is added!

## License
This project is licensed under the MIT License. See the [LICENSE](LICENSE) file for details.

---
Happy coding and learning!